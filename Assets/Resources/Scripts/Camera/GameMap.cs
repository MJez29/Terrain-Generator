using UnityEngine;
using System;
using System.Collections;
using System.Globalization;

//GameMap.cs
//Author(s): Michal Jez
//Shadowstruck Software

//This class creates the GameMap
//The terrain is generated by:
//  1. Calculating the highest point of dirt at a specific x-coordinate using 1D Perlin Noise
//  2. Adding caves using 2D Simplex Noise
//  3. Generates bridges
//  4. Generate ladders extending from bridges
//  5. Generate trenches and their accompanying watch towers
//  6. Generates boxes randomly on the map
//  7. Generates explosives randomly on the map
//  ---THIS IS HOW FAR I AM SO FAR---
//  8. Generates the start point for the game
//  9. Generates the checkpoint at the end of the map
//  10. Generates the Enemies on the map
//
//There are multiple types of biomes that the Game is played in
//Current biomes are:
//  - The Country
//      - The map is mainly made up of dirt blocks
//      - There are trenches with accompanying watchtowers
//      - Bridges and ladders provide accessibility to all regions of the map

public class GameMap : MonoBehaviour
{
    private PrimitiveBlock[][] map;             //2D array that holds all blocks that the players and enemies can interact with
    private PrimitiveBlock[][] backMap;         //2D array that holds the blocks that are visible in the background
    private ArrayList backStuff;

    //GameMap constants (constants are implicitly static)
    public const int BIOME_WIDTH = 200;			//200 Unity units
    public const int BIOME_HEIGHT = 50;			//50 Unity units
    public const int BLOCK_WIDTH = 1;			//50 pixels, 1 Unity unit
    public const int BLOCK_HEIGHT = 1;          //50 pixels, 1 Unity unit

    //Sampling frequency and position for heightmap noise sampling
    private double xHeightFreq;                 //Frequency
    private double xHeight;                     //Position

    //Sampling frequencies and position for cave noise sampling
    private double xCaveFreq;                   //Frequencies
    private double yCaveFreq;
    private double xCave;                       //Position
    private double yCave;
    private double topLevelScale;               //Scales the top level of dirt so that it will always fall within a certain range

    private double topLevelSum;
    private int numTopLevels;
    private double avgTopLevel;
    

    private int[] maxHeights;

    private System.Random rand;

    //All the base blocks that are used for Instantiating
    private GameObject baseDirt, baseBridge, baseLadder, baseTrench, baseRoof, basePlatform, baseBackgroundBlock, baseBox, baseExplosive;

    //All the base structures in the Game
    private GameObject baseTent, baseCampFire, baseTree, baseTorch;

    //Makes the GameMap for the current biome
    void Start()
    {
        rand = new System.Random();

        LoadSprites();

        MakeBaseBlocks();

        Debug.Log("DONE1 at " + DateTime.Now.Millisecond);

        //Makes the map
        MakeMap(MapType.FOREST);
        Debug.Log("DONE2 at " + DateTime.Now.Millisecond);

        //Initializes the blocks
        InitBlocks();
        
        Debug.Log("DONE3 at " + DateTime.Now.Millisecond);

        gameObject.GetComponent<GameTime>().StartTime();
    }

    //Loads all the sprites once Unity is ready
    private void LoadSprites()
    {
        Dirt.LoadSprites();
        Ladder.LoadSprites();
        Bridge.LoadSprites();
        Trench.LoadSprites();
        Roof.LoadSprites();
        Platform.LoadSprites();
        BackgroundBlock.LoadSprites();
        Box.LoadSprites();
    }

    //Loads the base Block prefabs that every new GameObject is Instantiated from
    private void MakeBaseBlocks()
    {
        baseDirt = Resources.Load("Prefabs/Blocks/dirt") as GameObject;
        baseBridge = Resources.Load("Prefabs/Blocks/bridge") as GameObject;
        baseLadder = Resources.Load("Prefabs/Blocks/ladder") as GameObject;
        baseTrench = Resources.Load("Prefabs/Blocks/trench") as GameObject;
        basePlatform = Resources.Load("Prefabs/Blocks/platform") as GameObject;
        baseRoof = Resources.Load("Prefabs/Blocks/roof") as GameObject;
        baseBackgroundBlock = Resources.Load("Prefabs/Blocks/backgroundblock") as GameObject;
        baseBox = Resources.Load("Prefabs/Blocks/box") as GameObject;
        baseExplosive = Resources.Load("Prefabs/Blocks/Explosive") as GameObject;
    }

    private void MakeForestStructures()
    {
        baseTent = Resources.Load("Prefabs/Structures/Tent") as GameObject;
        baseCampFire = Resources.Load("Prefabs/Fire/Camp Fire") as GameObject;
        baseTree = Resources.Load("Prefabs/Structures/Palm tree") as GameObject;
        baseTorch = Resources.Load("Prefabs/Fire/Torch") as GameObject;
    }

    //Makes the map piece by piece
    private void MakeMap(MapType type)
    {
        //Initializes the Array of Arrays that holds every block in the game
        map = new PrimitiveBlock[BIOME_WIDTH][];
        backMap = new PrimitiveBlock[BIOME_WIDTH][];

        for (int i = 0; i < BIOME_WIDTH; i++)
        {
            map[i] = new PrimitiveBlock[BIOME_HEIGHT];
            backMap[i] = new PrimitiveBlock[BIOME_HEIGHT];
        }

        for (int x = 0; x < BIOME_WIDTH; x++)
        {
            for (int y = 0; y < BIOME_HEIGHT; y++)
            {
                map[x][y] = new PrimitiveBlock(x, y);
                backMap[x][y] = new PrimitiveBlock(x, y);
            }
        }

        switch (type)
        {
            case MapType.FOREST:
                MakeForest();
                break;
            case MapType.PLAINS:
                MakePlains();
                break;
        }
        
    }

    //Makes a map that is set in the forest
    //In the forest there are more and larger caves whilst the terrain is more hilly
    private void MakeForest()
    {
        MakeForestStructures();

        //Sets the frequencies and positions to sample noise

        //The starting position for the height generator and the frequency that the noise is sampled at
        xHeight = rand.Next(-1000, 0);
        xHeightFreq = 1.0 / rand.Next(80, 120);

        //The frequencies for sampling noise for the cave generation
        xCaveFreq = 0.2;
        yCaveFreq = 0.25;

        //Starting position of the x-value for the cave noise sampling
        xCave = rand.Next(-1000, 0);

        //To contain the maximum amount of caves and to have the most hills the more area that the dirt can be found in the better
        topLevelScale = 1.0;

        GenerateDirt();
        GenerateTrees();
        GenerateBridges();
        GenerateBoxes();
        GenerateExplosives();
        GenerateCamps();
        GenerateTorches();
        
    }

    //Makes a map that is set in the plains
    //Plains are less tall when compared to forests and also have less caves that are less tall but longer
    //Plains contain trenches
    private void MakePlains()
    {
        //Sets the frequencies and positions to sample noise

        //The starting position for the height generator and the frequency that the noise is sampled at
        xHeight = rand.Next(-1000, 0);
        xHeightFreq = 1.0 / rand.Next(180, 220);

        //The frequencies for sampling noise for the cave generation
        xCaveFreq = 0.1;
        yCaveFreq = 0.6;

        //Starting position of the x-value for the cave noise sampling
        xCave = rand.Next(-1000, 0);

        topLevelScale = 0.6;

        GenerateDirt();
        GenerateBridges();
        GenerateTrenches();

        GenerateBoxes();
    }

    //Generates all the dirt in the map
    //A dirt block will only be generated at a specific position iff
    //  - Its y-coordinate is at or below the max dirt height for that x-coordinate
    //  - There is not a cave located at its position
    private void GenerateDirt()
    {
        //Variables used to calculate the average height of the top level of dirt
        topLevelSum = 0.0;
        numTopLevels = 0;
        avgTopLevel = 0.0;

        //The max height of every column of blocks
        maxHeights = new int[BIOME_WIDTH];
        for (int i = 0; i < BIOME_WIDTH; i++)
        {
            maxHeights[i] = -1;
        }

        //Variables used to calculate the average height of the top level of dirt
        topLevelSum = 0.0;
        numTopLevels = 0;
        avgTopLevel = 0.0;
        //Generates dirt
        for (int x = 0; x < BIOME_WIDTH; x++, xHeight += xHeightFreq, xCave += xCaveFreq)
        {
            //The top level that the dirt will go to
            double topLevel = PerlinNoise1D.getNoise(xHeight) * BIOME_HEIGHT * topLevelScale;
            if (topLevel > (double)BIOME_HEIGHT - 1) topLevel = BIOME_HEIGHT - 1;

            topLevelSum += topLevel;
            ++numTopLevels;
            avgTopLevel = topLevelSum / numTopLevels;
            yCave = 0.0;
            double thresh = 1.0;
            for (int y = (int) topLevel; y >= 0; y--, yCave += yCaveFreq)
            {
                double n = ((SimplexNoise2D.octaveNoise2D(5, 0.1, 0.2, xCave, yCave) + 1.0) / 2.0 * 5.0);

                //Builds a dirt block if it is below the max height generated by the height generator and if there isnt a cave there
                if ((int) n > 1 || y > topLevel * topLevelScale * 1.2)
                {
                    if (maxHeights[x] == -1)
                    {
                        maxHeights[x] = y;
                    }
                    map[x][y].SetBT(BlockType.DIRT); 
                }
                if (n >= thresh)
                {
                    backMap[x][y] = new PrimitiveBlock(x, y, BlockType.DIRT);
                }
                else
                {
                    if (rand.Next(15) == 0)
                        thresh = rand.NextDouble() + 1;
                }
            }
        }
    }

    //Generates trees on the map
    //Trees are spawned in the background and must fit the following mold:
    // A A A
    // A A A
    // A A A
    // A A A
    // A A A
    // A A A
    // D D D
    private void GenerateTrees()
    {
        for (int x = 5; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 0; y < BIOME_HEIGHT; y++)
            {
                //Check to see if all the blocks below are dirt blocks
                if ((backMap[x][y].bt != BlockType.DIRT || backMap[x + 1][y].bt != BlockType.DIRT || backMap[x + 2][y].bt != BlockType.DIRT) ||
                    rand.Next(3) != 0)
                    continue;

                bool treeFits = true;
                for (int ix = x; ix < x + 3 && treeFits; ix++)
                {
                    for (int iy = y + 1; iy < y + 6 && treeFits; iy++)
                    {
                        try {
                            treeFits = backMap[ix][iy].bt == BlockType.AIR;
                        } catch(IndexOutOfRangeException e) { e = null; }
                    }
                }

                if (treeFits)
                {
                    GameObject go = Instantiate(baseTree);
                    go.transform.position = new Vector2(x + 1, y + 1);
                    go.GetComponent<SpriteRenderer>().flipX = rand.Next(2) == 0;
                }
            }
        }
    }

    //Generates torches randomly on the map to provide additional light during the night
    //To generate a torch the area around this must look like:
    //Foreground:     Background:
        // A A A        D D D       /\/\/\
        // A A A        D D D       \____/
        // A A A        D D D         ||
        // . . .  Extra . . .
        //   D 
        //Blank spaces mean those blocks don't matter
    private void GenerateTorches()
    {
        for (int x = 2; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 2; y < BIOME_HEIGHT - 8; y++)
            {
                if (map[x + 1][y].CanWalkOn() && rand.Next(4) == 0)
                {
                    bool torchFits = true;
                    int extra = rand.Next(4);           //Torches can be 2-6 blocks above the ground
                    for (int ix = x; ix < x + 3 && torchFits; ix++)
                    {
                        for (int iy = y + 1 + extra; iy < y + 4 + extra && torchFits; iy++)
                        {
                            try {
                                torchFits = backMap[ix][iy].bt == BlockType.DIRT && map[ix][iy].bt == BlockType.AIR;
                            } catch(IndexOutOfRangeException e) { torchFits = false; e = null; }
                        }
                    }
                    //Only makes a torch if it fits the mold
                    if (torchFits)
                    {
                        Instantiate(baseTorch).transform.position = new Vector2(x + 1, y + 2 + extra);
                        x += 3;
                    }
                }
            }
        }
    }

    //Generates the bridges on the map
    //  - Calculates how many bridges to build
    //  - Calculates the y-coordinate of each bridge and builds the bridge
    //  - Adds ladders as it goes on
    private void GenerateBridges()
    {
        int numBridges = rand.Next(2, 4);           //The number of bridges that will be generated
        int[] heights = new int[numBridges];        //The y-values of each bridge

        //Finds a y-value to build a bridge at and then builds it
        for (int i = 0; i < numBridges; i++)
        {
            //Finds a height to build a bridge at

            int h = 0;
            bool b = true;
            //Continues looping until it finds a suitable height to build a bridge at
            //To be suitable it can't be too close to any other bridge (must be >= 6 blocks away)
            while (b)
            {
                h = rand.Next(0, (int)(topLevelSum / numTopLevels * 0.9));

                //Goes through all the previous heights to see if the current height is too close to any of them
                foreach (int n in heights)
                {
                    //If height is too close
                    if (Mathf.Abs(n - h) < 6.0f)
                    {
                        b = true;
                        break;
                    }
                    //Height distance is fine, can stop looping
                    else
                    {
                        b = false;
                    }
                }
                
            }
            heights[i] = h;

            //Builds a bridge at that height

            bool dirtR = map[BIOME_WIDTH - 1][h].bt == BlockType.DIRT;						//If the rightmost block is dirt
            bool dirtL = map[0][h].bt == BlockType.DIRT;			                        //If the leftmost block is dirt
            int dist = 2;                                                       //The number of blocks in between ladder blocks
            int lastLadderR = dist + 1, lastLadderL = dist + 1;			        //The number of blocks since a ladder was built in that direction
            

            //Builds the bridge from the left and from the right at the same time
            //Unless the first block on either side is dirt, it will not build the bridge from that side until it encounters dirt
            for (int lx = 0, rx = BIOME_WIDTH - 1; lx <= rx; lx++, rx--)
            {
                //Builds from the right
                //Checks block to see if it's air
                if (map[rx][h].bt == BlockType.AIR)
                {
                    //If it is air and there has been a dirt block on the right already it will place a bridge block there
                    if (dirtR)
                    {
                        if (lastLadderR++ > dist)
                        {
                            if (MakeLadder(rx, h))
                                lastLadderR = 0;
                        }
                        map[rx][h].SetBT(BlockType.BRIDGE);
                    }
                }
                else dirtR = true;

                //Builds from the left
                //Checks block to see if it's air
                if (map[lx][h].bt == BlockType.AIR)
                {
                    //If it is air and there has been a dirt block on the left already it will place a bridge block there
                    if (dirtL)
                    {
                        if (lastLadderL++ > dist)
                        {
                            if (MakeLadder(lx, h))
                                lastLadderL = 0;
                        }
                        map[lx][h].SetBT(BlockType.BRIDGE);
                    }
                }
                else dirtL = true;
            }
        }
    }
    
    //Makes a ladder given that the (x, y) passed in is going to be a Bridge block
    private bool MakeLadder(int x, int y)
    {
        bool madeLadder = false;

        //There is a 1/5 chance that a ladder will be considered being built
        if (rand.Next(5) == 0)
        {
            //Attempts to build a ladder towards the sky
            //Will not build up if:
            //  -There is only air above it
            //If it will build, it will build up until it reaches air or until it reaches a bridge
            //1/2 chance that a ladder will be built upwards
            if (rand.Next(2) == 0)
            {
                bool buildToSky = false;
                //Checks to see if there is just air above the ladder
                for (int i = y + 1; i < BIOME_HEIGHT; i++)
                {
                    if (map[x][i].bt != BlockType.AIR)
                    {
                        buildToSky = true;
                        break;
                    }
                }

                bool reachedDirt = false;

                //Builds a bridge upwards if it can
                if (buildToSky)
                {
                    //Goes upwards block by block adding a ladder
                    for (int iy = y + 1; iy < BIOME_HEIGHT; iy++)
                    {
                        //Stops building upwards if it has reached a bridge
                        if (map[x][iy].bt == BlockType.BRIDGE)
                            break;

                        //Stops building upwards if it has traversed through dirt and just reached air
                        if (reachedDirt && map[x][iy].bt == BlockType.AIR)
                            break;

                        //Checks to see if the current block is dirt
                        if (map[x][iy].bt == BlockType.DIRT)
                            reachedDirt = true;

                        map[x][iy].SetBT(BlockType.LADDER);
                    }

                    madeLadder = true;
                }
            }

            //Attempts to build a ladder towards the ground
            //Will only build if
            //  - There is air below
            //  - Below the air pocket there is dirt
            //There is a 1/2 chance that a ladder will be considered to be built downwards
            if (rand.Next(2) == 0)
            {
                bool reachedAir = false;
                bool reachedDirt = false;

                //Checks to see if it can build downwards
                for (int iy = y -  1; iy >= 0; iy--)
                {
                    //If block is dirt
                    if (map[x][iy].bt == BlockType.AIR)
                        reachedAir = true;
                    else
                        reachedDirt = true;
                }

                //If a ladder can be built
                //A ladder is built
                if (reachedDirt && reachedAir)
                {
                    reachedDirt = false;
                    reachedAir = false;

                    //Builds a bridge downwards
                    for (int iy = y -  1; iy >= 0; iy--)
                    {
                        //If it has reached a bridge
                        if (map[x][iy].bt == BlockType.BRIDGE)
                            break;

                        //If the current block is dirt
                        if (map[x][iy].bt == BlockType.DIRT)
                        {
                            if (reachedDirt && reachedAir)
                                break;
                            else
                                reachedDirt = true;
                        }

                        //If the current block is air
                        if (map[x][iy].bt == BlockType.AIR)
                            reachedAir = true;

                        map[x][iy].SetBT(BlockType.LADDER);
                    }

                    madeLadder = true;
                }
            }
        }

        return madeLadder;
    }

    //Generates camps in forest maps
    //Camps have a tent and a campfire
    private void GenerateCamps()
    {
        bool lastWasSolid;
        bool lastWasAir;
        for (int x = 20; x < BIOME_WIDTH - 10; x += rand.Next(10) + 10)
        {
            lastWasSolid = false;
            lastWasAir = true;
            int toAdd = 0;
            
            //If we were to always go from the top the camps would always be found near the top and vice versa if 
            //we go from the bottom
            //To resolve this we go randomly up or down
            bool up = rand.NextDouble() < 0.5;


            for (int y = (up ? 5 : BIOME_HEIGHT - 5); up ? y < BIOME_HEIGHT - 5 : y > 5; y += up ? 1 : -1)
            {
                //If its going up and the current block is air and the block above it is air and the block below it is solid
                //It attempts to make a camp around that position
                //Also sets lastWasSolid to the correct state
                if (up)
                {
                    if (map[x][y].bt == BlockType.AIR)
                    {
                        if (lastWasSolid && map[x][y + 1].bt == BlockType.AIR)
                        {
                            toAdd = MakeCampAround(x, y, 0);

                            //If the making of the camp was successful it moves on to the next x-position
                            if (toAdd > 0) break;
                        }
                        lastWasSolid = false;
                    }
                    else lastWasSolid = map[x][y].bt != BlockType.LADDER;
                }

                //If its going down and the current block is air and the block above it is air and the block below it is solid
                //It attempts to make a camp around that position
                //Also sets lastWasAir to the correct state
                else
                {
                    if (map[x][y].bt == BlockType.AIR)
                    {
                        if (lastWasAir && map[x][y - 1].bt != BlockType.AIR && map[x][y - 1].bt != BlockType.LADDER)
                        {
                            toAdd = MakeCampAround(x, y, 0);

                            //If the making of the camp was successful it moves on to the next x-position
                            if (toAdd > 0) break;
                        }
                        lastWasAir = true;
                    }
                    else lastWasAir = false;
                }
            }

            //To spread out camps an extra n units are added to the x-value so that camps don't spawn too close together
            x += toAdd;
        }
    }

    //Makes a camp around the given (x, y)
    //(x, y) is the bottom-middle part of the tent
    //It generates a campfire around (x, y) but at no specific location
    //Attempts to find 2 consecutive blocks with the same elevation, if unsuccessful it will force the camp in by adding and/or removing blocks
    //As necessary
    private int MakeCampAround(int x, int y, int attempts)
    {
        //Attempts to build the tent

        bool tryRight = false, tryLeft = false;

        //Checks the Blocks to the left
        map[x - 1][y].SetBT(BlockType.AIR);
        map[x - 1][y + 1].SetBT(BlockType.AIR);
        if (map[x - 1][y - 1].bt == BlockType.AIR)
            map[x - 1][y - 1].SetBT(BlockType.DIRT);
        else if (map[x - 1][y - 1].bt == BlockType.LADDER)
            tryRight = true;

        //Checks blocks to the right
        map[x + 1][y].SetBT(BlockType.AIR);
        map[x + 1][y + 1].SetBT(BlockType.AIR);
        if (map[x + 1][y - 1].bt == BlockType.AIR)
            map[x + 1][y - 1].SetBT(BlockType.DIRT);
        else if (map[x + 1][y - 1].bt == BlockType.LADDER)
            tryLeft = true;

        //If the camp cannot be made at (x, y) it tries at (x +or- 1, y)
        if (tryRight || tryLeft)
        {
            if (attempts < 4)
                return MakeCampAround(tryLeft ? x - 1 : x + 1, y, attempts + 1);
            return 0;
        }

        GameObject go = Instantiate(baseTent);
        Vector2 tPos = new Vector2(x, y + BLOCK_HEIGHT / 2.0f);         //Position of the tent
        go.transform.position = tPos;

        //Blocks to the immediate left and right of the tent are air blocks
        map[x - 2][y].SetBT(BlockType.AIR);
        map[x - 2][y + 1].SetBT(BlockType.AIR);
        map[x - 2][y + 2].SetBT(BlockType.AIR);
        if (map[x - 2][y - 1].bt == BlockType.AIR || map[x - 2][y - 1].bt == BlockType.LADDER)
            map[x - 2][y - 1].SetBT(BlockType.DIRT);
        map[x + 2][y].SetBT(BlockType.AIR);
        map[x + 2][y + 1].SetBT(BlockType.AIR);

        //Builds the campfire

        //bool upOne = map[x - 2][y].bt != BlockType.AIR || map[x - 3][y].bt != BlockType.AIR || map[x - 4][y].bt != BlockType.AIR;
        //bool same = 

        double sum = 0.0;
        for (int ix = x - 3; ix > x - 6; ix--)
        {
            if (map[ix][y].CanWalkOn())//.bt != BlockType.AIR || map[ix][y].bt != BlockType.LADDER)
                sum += 1.0;
            else if (map[ix][y - 1].CanWalkOn())//.bt != BlockType.AIR || map[ix][y - 1].bt != BlockType.LADDER)
                sum += 0.0;
            else
                sum -= 1.0;
        }

        int avg = (int)(sum / 3.0 + 0.5);
        map[x - 3][y + 1 + avg].SetBT(BlockType.AIR);
        map[x - 3][y + avg].SetBT(BlockType.AIR);
        map[x - 4][y + 1 + avg].SetBT(BlockType.AIR);
        map[x - 4][y + avg].SetBT(BlockType.AIR);
        map[x - 5][y + 1 + avg].SetBT(BlockType.AIR);
        map[x - 5][y + avg].SetBT(BlockType.AIR);
        if (map[x - 3][y - 1 + avg].bt == BlockType.AIR || map[x - 3][y - 1 + avg].bt == BlockType.LADDER)
            map[x - 3][y - 1 + avg].SetBT(BlockType.DIRT);
        if (map[x - 4][y - 1 + avg].bt == BlockType.AIR || map[x - 4][y - 1 + avg].bt == BlockType.LADDER)
            map[x - 4][y - 1 + avg].SetBT(BlockType.DIRT);
        if (map[x - 5][y - 1 + avg].bt == BlockType.AIR || map[x - 5][y - 1 + avg].bt == BlockType.LADDER)
            map[x - 5][y - 1 + avg].SetBT(BlockType.DIRT);

        go = Instantiate(baseCampFire);
        Vector2 cfPos = new Vector2(x - 4, y + avg);            //Position of campfire
        go.transform.position = cfPos;

        gameObject.GetComponent<CampController>().MakeCamp(cfPos, tPos);

        return 20;
    }

    private Vector2 FindCampGuardRange(Vector2 tent, Vector2 campfire)
    {
        int x = (int) (campfire.x - BLOCK_WIDTH * 1.5);
        int y = (int) (tent.y - BLOCK_HEIGHT / 2f);

        float max = tent.x;

        while (x > 0 && y > 0 && y < BIOME_HEIGHT - 1)
        {
            //If the block to walk on has the same elevation as the previous x-value
            if (!map[x][y].CanWalkOn() && !map[x][y + 1].CanWalkOn() && map[x][y - 1].CanWalkOn())
                x--;
            //If the block to walk on is one above the previous x-value and there is enough space for the enemy to jump onto it
            else if (map[x][y].CanWalkOn() && !map[x][y + 1].CanWalkOn() && !map[x][y + 2].CanWalkOn() && !map[x + 1][y + 2].CanWalkOn())
            { x--; y++; }
            else if (map[x][y - 2].CanWalkOn() && !map[x][y - 1].CanWalkOn() && !map[x][y].CanWalkOn() && !map[x][y + 1].CanWalkOn())
            { x--; y--; }
            else
                break;
        }

        return new Vector2(x, max);
    }
    
    //Jumps a few blocks every time and checks to see if a trench can be built at that x-value
    private void GenerateTrenches()
    {
        for (int x = 20; x < BIOME_WIDTH - 15; x += rand.Next(5) + 5)
        {
            x += MakeTrench(x);
        }
    }

    //A trench is a predefined structure and will only be built if the nearby terrain can be molded around the trench
    //Trenches look along the lines of
    //          X
    //          X   X X X
    //          X       X
    //          X       X
    //          X X X X X
    //Where an X represents a block of the walls of the trench
    private int MakeTrench(int x)
    {
        for (int y = BIOME_HEIGHT - 10; y > 10; y--)
        {
            //Checks to see if there is dirt surrounding the perimeter of trench to be built and air above for the enemies to be able to escape
            if (map[x][y].bt == BlockType.AIR && map[x][y - 1].bt == BlockType.AIR &&		//If the space above it is air
                    map[x + 1][y].bt == BlockType.AIR && map[x + 1][y - 1].bt == BlockType.AIR &&
                    map[x - 1][y - 2].bt == BlockType.DIRT && map[x - 1][y - 3].bt == BlockType.DIRT &&
                    map[x - 1][y - 4].bt == BlockType.DIRT && map[x - 1][y - 5].bt == BlockType.DIRT &&
                    map[x - 1][y - 6].bt == BlockType.DIRT && map[x - 1][y - 7].bt == BlockType.DIRT &&
                    map[x][y - 7].bt == BlockType.DIRT && map[x + 1][y - 7].bt == BlockType.DIRT &&
                    map[x + 2][y - 7].bt == BlockType.DIRT && map[x + 3][y - 7].bt == BlockType.DIRT &&
                    map[x + 4][y - 7].bt == BlockType.DIRT && map[x + 5][y - 7].bt == BlockType.DIRT &&
                    map[x + 6][y - 7].bt == BlockType.DIRT && map[x + 6][y - 6].bt == BlockType.DIRT &&
                    map[x + 6][y - 5].bt == BlockType.DIRT && map[x + 6][y - 4].bt == BlockType.DIRT &&
                    map[x + 6][y - 2].bt == BlockType.DIRT && map[x + 5][y - 2].bt == BlockType.DIRT &&
                    map[x + 4][y - 2].bt == BlockType.DIRT && map[x + 3][y - 2].bt == BlockType.DIRT &&
                    map[x + 2][y - 2].bt == BlockType.DIRT)
            {
                //Changes the blocks so that they become appropriate blocks
                //Goes column by column
                map[x][y - 2] = new PrimitiveBlock(x, y - 2, BlockType.TRENCH, Trench.TOP_LEFT_CORNER);
                map[x][y - 3] = new PrimitiveBlock(x, y - 3, BlockType.TRENCH, Trench.LEFT_WALL);
                map[x][y - 4] = new PrimitiveBlock(x, y - 4, BlockType.TRENCH, Trench.LEFT_WALL);
                map[x][y - 5] = new PrimitiveBlock(x, y - 5, BlockType.TRENCH, Trench.LEFT_WALL);
                map[x][y - 6] = new PrimitiveBlock(x, y - 6, BlockType.TRENCH, Trench.BOTTOM_LEFT_CORNER);

                map[x + 1][y - 2] = new PrimitiveBlock(x + 1, y - 2);
                map[x + 1][y - 3] = new PrimitiveBlock(x + 1, y - 3);
                map[x + 1][y - 4] = new PrimitiveBlock(x + 1, y - 4);
                map[x + 1][y - 5] = new PrimitiveBlock(x + 1, y - 5);
                map[x + 1][y - 6] = new PrimitiveBlock(x + 1, y - 6, BlockType.TRENCH, Trench.TOP_WALL, false, true);

                map[x + 2][y - 2] = new PrimitiveBlock(x + 2, y - 2, BlockType.DIRT);
                map[x + 2][y - 3] = new PrimitiveBlock(x + 2, y - 3, BlockType.TRENCH, Trench.TOP_CENTER_CORNER);
                map[x + 2][y - 4] = new PrimitiveBlock(x + 2, y - 4);
                map[x + 2][y - 5] = new PrimitiveBlock(x + 2, y - 5);
                map[x + 2][y - 6] = new PrimitiveBlock(x + 2, y - 6, BlockType.TRENCH, Trench.TOP_WALL, false, true);

                map[x + 3][y - 2] = new PrimitiveBlock(x + 3, y - 2, BlockType.DIRT);
                map[x + 3][y - 3] = new PrimitiveBlock(x + 3, y - 3, BlockType.TRENCH, Trench.TOP_WALL);
                map[x + 3][y - 4] = new PrimitiveBlock(x + 3, y - 4);
                map[x + 3][y - 5] = new PrimitiveBlock(x + 3, y - 5);

                //Spawner spawner = new Spawner(x + 3, y - 6, Spawner.SLOW);          //The spawner is 2 blocks wide
                //THIS IS WHERE THE SPAWNER WILL GO IF WE WANT TO KEEP IT
                map[x + 3][y - 6] = new PrimitiveBlock(x + 3, y - 6, BlockType.TRENCH, Trench.TOP_WALL, false, true);
                map[x + 4][y - 6] = new PrimitiveBlock(x + 4, y - 6, BlockType.TRENCH, Trench.TOP_WALL, false, true);

                map[x + 4][y - 2] = new PrimitiveBlock(x + 4, y - 2, BlockType.DIRT);
                map[x + 4][y - 3] = new PrimitiveBlock(x + 4, y - 3, BlockType.TRENCH, Trench.TOP_WALL);
                map[x + 4][y - 4] = new PrimitiveBlock(x + 4, y - 4);
                map[x + 4][y - 5] = new PrimitiveBlock(x + 4, y - 5);

                map[x + 5][y - 2] = new PrimitiveBlock(x + 5, y - 2, BlockType.DIRT);
                map[x + 5][y - 3] = new PrimitiveBlock(x + 5, y - 3, BlockType.TRENCH, Trench.BOTTOM_LEFT_CORNER, true, true);
                map[x + 5][y - 4] = new PrimitiveBlock(x + 5, y - 4, BlockType.TRENCH, Trench.LEFT_WALL, true, false);
                map[x + 5][y - 5] = new PrimitiveBlock(x + 5, y - 5, BlockType.TRENCH, Trench.LEFT_WALL, true, false);
                map[x + 5][y - 6] = new PrimitiveBlock(x + 5, y - 6, BlockType.TRENCH, Trench.BOTTOM_LEFT_CORNER, true, false);
                GenerateWatchTower(x + 1, y + 1);
                y -= 6;
                return 10;
            }
        }
        return 0;
    }

    //This method finds the location to build the watchtower
    //(startX, startY) is 2 blocks above the top block of the air column that has dirt on either side
    private void GenerateWatchTower(int startX, int startY)
    {
        int op = rand.Next(2) * 2 - 1; 	//Either + or - 1, checks either to the right or left of trench first randomly

        for (int x = startX + 2 * op; Math.Abs(x - startX) < 6; /*x += op*/)
        {
            bool canBuild = true;
            for (int ix = x; canBuild && Math.Abs(x - ix) < 5; ix += op)
            {
                canBuild = map[ix][startY].bt == BlockType.AIR;
            }
            MakeWatchTower((op < 0) ? x - 4 : x, startY);
            return;
        }
    }

    private void MakeWatchTower(int sx, int sy)
    {
        //Builds the horizontal platform that an enemy commander will stand on
        map[sx][sy] = new PrimitiveBlock(sx, sy, BlockType.PLATFORM, Platform.WATCH_TOWER_LEFT);
        map[sx + 1][sy] = new PrimitiveBlock(sx + 1, sy, BlockType.PLATFORM, Platform.WATCH_TOWER_MIDDLES[rand.Next(Platform.WATCH_TOWER_MIDDLES.Length)]);
        map[sx + 2][sy] = new PrimitiveBlock(sx + 2, sy, BlockType.PLATFORM, Platform.WATCH_TOWER_MIDDLES[rand.Next(Platform.WATCH_TOWER_MIDDLES.Length)]);
        map[sx + 3][sy] = new PrimitiveBlock(sx + 3, sy, BlockType.PLATFORM, Platform.WATCH_TOWER_MIDDLES[rand.Next(Platform.WATCH_TOWER_MIDDLES.Length)]);
        map[sx + 4][sy] = new PrimitiveBlock(sx + 4, sy, BlockType.PLATFORM, Platform.WATCH_TOWER_LEFT, true, false);

        //CODE FOR PILLARS
        //Builds the left pillar that supports the platform
        for (int y = sy - 1; y >= 0; y--)
        {
            if (map[sx][y].bt == BlockType.AIR)
            {
                backMap[sx][y].SetBT(BlockType.BACKGROUND_BLOCK);
                backMap[sx][y].spr = BackgroundBlock.WATCH_TOWER_PILLAR;
            }
            else break;
        }

        //Creates the right pillar that supports the platform
        for (int y = sy - 1; y >= 0; y--)
        {
            if (map[sx + 4][y].bt == BlockType.AIR)
            {
                backMap[sx + 4][y].SetBT(BlockType.BACKGROUND_BLOCK);
                backMap[sx + 4][y].spr = BackgroundBlock.WATCH_TOWER_PILLAR;
            }
            else break;
        }

        //Creates the left pillar that supports the roof
        backMap[sx][sy + 1] = new PrimitiveBlock(sx, sy + 1, BlockType.BACKGROUND_BLOCK, BackgroundBlock.WATCH_TOWER_PILLAR);
        backMap[sx][sy + 2] = new PrimitiveBlock(sx, sy + 2, BlockType.BACKGROUND_BLOCK, BackgroundBlock.WATCH_TOWER_PILLAR);
        //Creates the right pillar that supports the roof
        backMap[sx + 4][sy + 1] = new PrimitiveBlock(sx + 4, sy + 1, BlockType.BACKGROUND_BLOCK, BackgroundBlock.WATCH_TOWER_PILLAR);
        backMap[sx + 4][sy + 2] = new PrimitiveBlock(sx + 4, sy + 2, BlockType.BACKGROUND_BLOCK, BackgroundBlock.WATCH_TOWER_PILLAR);

        for (int i = 0; i < 5; i++)
        {
            //Adds the roof
            map[sx + i][sy + 4] = new PrimitiveBlock(sx + i, sy + 4, BlockType.ROOF, Roof.WATCH_TOWER_ROOF_TOP[i]);
            map[sx + i][sy + 3] = new PrimitiveBlock(sx + i, sy + 3, BlockType.ROOF, Roof.WATCH_TOWER_ROOF_BOTTOM[i]);

            //Makes space in between the roof and the platform for the enemy commander to walk
            map[sx + i][sy + 2].SetBT(BlockType.AIR);
            map[sx + i][sy + 1].SetBT(BlockType.AIR);
        }
    }

    //Generates boxes in random places around the map
    //The only requirement is that there is a block beneath where the box is to be spawned
    private void GenerateBoxes()
    {
        for (int x = 5; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 5; y < BIOME_HEIGHT - 1; y++)
            {
                if (map[x][y].bt == BlockType.AIR &&                //If current block is air
                    map[x][y - 1].bt != BlockType.TRENCH &&         //And block below is NOT a trench block,
                    map[x][y - 1].bt != BlockType.LADDER &&         //A ladder,
                    map[x][y - 1].bt != BlockType.ROOF &&           //A roof,
                    map[x][y - 1].bt != BlockType.PLATFORM &&       //A platform or
                    map[x][y - 1].bt != BlockType.AIR &&            //Air
                    rand.Next(10) == 0)
                    map[x][y].SetBT(BlockType.BOX);
            }
        }
    }

    private void GenerateExplosives()
    {
        for (int x = 5; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = BIOME_HEIGHT - 5; y > 4; y--)
            {
                if (map[x][y].bt == BlockType.AIR && (map[x][y - 1].bt == BlockType.DIRT || map[x][y - 1].bt == BlockType.BRIDGE) && rand.Next(50) == 0)
                {
                    map[x][y].SetBT(BlockType.EXPLOSIVE);
                }
            }
        }
    }

    //Initializes every Block as a GameObject
    private void InitBlocks()
    {
        //To make the edges of the dirt look nice a padded map is added where there is one layer of air around all 4 edges
        //Currently only used by Dirt.InitializeSprite()

        //Initializes the empty padded map
        PrimitiveBlock[][] paddedMap = new PrimitiveBlock[BIOME_WIDTH + 2][];
        PrimitiveBlock[][] paddedBackMap = new PrimitiveBlock[BIOME_WIDTH + 2][];
        for (int i = 0; i < BIOME_WIDTH + 2; i++)
        {
            paddedMap[i] = new PrimitiveBlock[BIOME_HEIGHT + 2];
            paddedBackMap[i] = new PrimitiveBlock[BIOME_HEIGHT + 2];
        }

        //Fills the padded map
        for (int x = 0; x < BIOME_WIDTH + 2; x++)
        {
            for (int y = 0; y < BIOME_HEIGHT + 2; y++)
            {
                //If it's a piece of padding to be added
                if (x == 0 || x == BIOME_WIDTH + 1 || y == 0 || y == BIOME_HEIGHT + 1)
                {
                    paddedMap[x][y] = new PrimitiveBlock(x, y);
                    paddedBackMap[x][y] = new PrimitiveBlock(x, y);
                }
                //If the block is a trench block, when initializing dirt sprites a Trench block is considered a Dirt block
                else if (map[x - 1][y - 1].bt == BlockType.TRENCH)
                    paddedMap[x][y] = new PrimitiveBlock(x, y, BlockType.DIRT);
                //If it's a block that's also present in map
                else
                {
                    paddedMap[x][y] = map[x - 1][y - 1];
                    paddedBackMap[x][y] = backMap[x - 1][y - 1];
                }
            }
        }

        GameObject go;
        PrimitiveBlock pb;
        //Initializes every block
        for(int x = 0; x < BIOME_WIDTH; x++)
        {
            for(int y = 0; y < BIOME_HEIGHT; y++)
            {
                pb = map[x][y];
                //Adds the correct scripts (if any) to 
                switch (pb.bt)
                {
                    case BlockType.DIRT:
                        go = Instantiate<GameObject>(baseDirt);
                        Dirt dirt = go.GetComponent<Dirt>();
                        dirt.SetPosition(pb.x, pb.y);
                        dirt.InitializeSprite(paddedMap);
                        break;
                    case BlockType.BRIDGE:
                        go = Instantiate<GameObject>(baseBridge);
                        Bridge bridge = go.GetComponent<Bridge>();
                        bridge.SetPosition(pb.x, pb.y);
                        bridge.InitializeSprite(map);
                        break;
                    case BlockType.LADDER:
                        go = Instantiate<GameObject>(baseLadder);
                        Ladder ladder = go.GetComponent<Ladder>();
                        ladder.SetPosition(pb.x, pb.y);
                        ladder.InitializeSprite(map);
                        break;
                    case BlockType.TRENCH:
                        go = Instantiate<GameObject>(baseTrench);
                        Trench trench = go.GetComponent<Trench>();
                        trench.SetPosition(pb.x, pb.y);
                        trench.InitializeSprite(map);
                        break;
                    case BlockType.PLATFORM:
                        go = Instantiate<GameObject>(basePlatform);
                        Platform platform = go.GetComponent<Platform>();
                        platform.SetPosition(pb.x, pb.y);
                        platform.InitializeSprite(map);
                        break;
                    case BlockType.ROOF:
                        go = Instantiate<GameObject>(baseRoof);
                        Roof roof = go.GetComponent<Roof>();
                        roof.SetPosition(pb.x, pb.y);
                        roof.InitializeSprite(map);
                        break;
                    case BlockType.BOX:
                        go = Instantiate<GameObject>(baseBox);
                        Box box = go.GetComponent<Box>();
                        box.SetPosition(pb.x, pb.y);
                        box.InitializeSprite(map);
                        break;
                    case BlockType.EXPLOSIVE:
                        go = Instantiate(baseExplosive);
                        Explosive e = go.GetComponent<Explosive>();
                        e.SetPosition(pb.x, pb.y);
                        break;
                }

                pb = backMap[x][y];
                BackgroundBlock bb;
                switch(pb.bt)
                {
                    case BlockType.BACKGROUND_BLOCK:
                        go = Instantiate(baseBackgroundBlock);
                        bb = go.GetComponent<BackgroundBlock>();
                        bb.SetPosition(pb.x, pb.y);
                        bb.InitializeSprite(backMap);
                        //go.isStatic = true;
                        break;
                    case BlockType.DIRT:
                        go = Instantiate(baseBackgroundBlock);
                        bb = go.GetComponent<BackgroundBlock>();
                        bb.SetPosition(pb.x, pb.y);
                        Dirt.InitializeSprite(paddedBackMap, go.GetComponent<SpriteRenderer>(), pb.x, pb.y);
                        //go.isStatic = true;
                        break;
                }
            }
        }
    }
}

public enum MapType
{
    FOREST, PLAINS, CITY
}